Layer by Layer:
Consumer Layer (Blue) — Every possible caller: web apps, Slack bots, pipelines, 3rd party systems. They all talk one standard JSON contract — messages + thread_id + user_id in, content + trace_id out. The frontend teams own this boundary.
API Gateway Layer (Amber) — Kong handles JWT auth and rate limiting. The Agent Router directs requests to the right agent by domain/intent. PII scrubber runs before any logging. A Service Principal (sp-<agent-name>) is the identity that crosses into Databricks.
Agent Core Layer (Purple) — The heart of it. LangGraph graph (planner → tool executor → reflection → formatter), the Bedrock LLM Router via External Model endpoint (no boto3 in agent code), Memory Manager (handles thread loading, summarization, TTL), the Code Sandbox (warm cluster pool, isolated), and MLflow Registry (the immutable deployment artifact). The Agent Passport and Skills Registry sit here too.
Tool & Skill Layer (Green) — Everything the agent can do, all governed via Unity Catalog. External APIs, SQL/lakehouse queries, RAG Knowledge Domains, sandboxed code execution — all exposed as UC Functions so the LLM gets the docstring as its instruction, and SP grants control what the agent can reach.
Memory & Storage Layer (Teal) — Three types of memory (short-term threads, working scratchpad, long-term vector knowledge) plus the full Delta Lakehouse table set for payload logs, traces, tool execution logs, and feedback signals. UC handles lineage end-to-end.
Observability Layer (Pink) — MLflow Tracing (flame graph, trace_id propagated), Inference Tables (zero config), Datadog/OTel alerts, weekly evaluation pipeline, feedback loop into fine-tuning, and full SQL-queryable audit trail for compliance.
Builder SDK callout (Yellow) — The fluent Python API or YAML config that builder teams actually touch. Everything below .build() is invisible to them.